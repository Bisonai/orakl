name: Dispatch Deploy
on:
  workflow_dispatch:
    inputs:
      network:
        description: "Network"
        required: true
        type: choice
        options:
          - "Baobab"
          - "Cypress"
      application:
        description: "Service"
        required: true
        type: choice
        options:
          - "cli"
          - "aggregator"
          - "vrf"
          - "api"
          - "request-response"
          - "delegator"
          - "fetcher"
          - "por"
          - "node"
          - "boot-api"
          - "sentinel"
      image:
        description: "Image Version"
        required: true
        type: choice
        default: "new"
        options:
          - new
          - cli:vtestversion
          - cli:vtestversion
          - cli:vtestversion
          - cli:vtestversion
          - cli:vtestversion
jobs:
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.network == 'Baobab' }}
    outputs:
      tag_date: ${{ steps.tag.outputs.date }}
      tag_git_hash: ${{ steps.tag.outputs.git_hash }}
      service: ${{ steps.tag.outputs.service }}
      ecr_url: ${{ steps.tag.outputs.ecr_url }}
      version: ${{ steps.package.outputs.version }}
    steps:
      - uses: actions/checkout@master
      - name: Get time TAG
        id: tag
        run: "echo \"date=$(date +'%Y%m%d.%H%M')\" >> $GITHUB_OUTPUT\necho \"git_hash=$(git rev-parse --short HEAD)\" >> $GITHUB_OUTPUT\nservice=\"${{ github.event.inputs.application }}\"\nif [[ \"${{ github.event.inputs.application }}\" == \"vrf\" || \"${{ github.event.inputs.application }}\" == \"request-response\" || \"${{ github.event.inputs.application }}\" == \"aggregator\" ]]; then\n  service=\"core\"\nfi            \necho \"service=$service\" >> $GITHUB_OUTPUT\necho \"ecr_url=public.ecr.aws/bisonai/orakl-${service}\" >> $GITHUB_OUTPUT\n"
      - name: Get package version
        id: package
        run: "if [[ \"${{ steps.tag.outputs.service }}\" == \"cli\" || \"${{ steps.tag.outputs.service }}\" == \"fetcher\" || \"${{ steps.tag.outputs.service }}\" == \"core\" ]]; then\n  echo \"version=$(node -p -e \"require('./\"${{ steps.tag.outputs.service }}\"/package.json').version\")\" >> $GITHUB_OUTPUT\nelse \n  if [[ \"${{ steps.tag.outputs.service }}\" == \"boot-api\" ]]; then\n    version=$(cat ./node/.version)\n  else\n    version=$(cat ./${{ steps.tag.outputs.service }}/.version)\n  fi\n  echo \"version=$version\" >> $GITHUB_OUTPUT\nfi\n"
  # build:
  #   name: Build
  #   runs-on: ubuntu-latest
  #   needs: prepare
  #   if: ${{ github.event.inputs.network == 'Baobab' }}
  #   permissions:
  #     id-token: write
  #     contents: read
  #   outputs:
  #     img_tag: ${{ steps.img-tag.outputs.img_tag }}
  #   steps:
  #     - uses: actions/checkout@master
  #     - name: Setup Go
  #       uses: actions/setup-go@v4
  #       with:
  #         go-version: "1.22.3"
  #         check-latest: true
  #         cache-dependency-path: |
  #           ./${{ needs.prepare.outputs.service }}/go.sum
  #           ./${{ needs.prepare.outputs.service }}/go.mod
  #       if: ${{ needs.prepare.outputs.service != 'core' || needs.prepare.outputs.service != 'fetcher' || needs.prepare.outputs.service != 'cli' }}
  #     - name: docker build ${{ github.event.inputs.application }}
  #       run: SERVICE_NAME=orakl-${{ needs.prepare.outputs.service }} docker compose -f docker-compose.build.yaml build
  #     - name: configure aws credentials
  #       uses: aws-actions/configure-aws-credentials@v2
  #       with:
  #         aws-region: us-east-1
  #         role-to-assume: ${{ secrets.ROLE_ARN }}
  #     - name: login to amazon ecr
  #       id: login-ecr-public
  #       uses: aws-actions/amazon-ecr-login@v1
  #       with:
  #         registry-type: public
  #     - name: publish image to ecr
  #       run: |
  #         docker tag orakl-${{ needs.prepare.outputs.service }} ${{ needs.prepare.outputs.ecr_url }}:latest
  #         docker push ${{ needs.prepare.outputs.ecr_url }}:latest
  #         docker tag ${{ needs.prepare.outputs.ecr_url }}:latest ${{ needs.prepare.outputs.ecr_url }}:v${{ needs.prepare.outputs.version }}.${{ needs.prepare.outputs.tag_date }}.${{ needs.prepare.outputs.tag_git_hash }}
  #         docker push ${{ needs.prepare.outputs.ecr_url }}:v${{ needs.prepare.outputs.version }}.${{ needs.prepare.outputs.tag_date }}.${{ needs.prepare.outputs.tag_git_hash }}
  #     - name: image tag output
  #       id: img-tag
  #       run: echo "img_tag=v${{ needs.prepare.outputs.version }}.${{ needs.prepare.outputs.tag_date }}.${{ needs.prepare.outputs.tag_git_hash }}" >> $GITHUB_OUTPUT
  # post-slack-image-upload:
  #   name: Slack message for image upload
  #   needs: [prepare, build]
  #   uses: ./.github/workflows/post.slack.yaml
  #   with:
  #     status: "Success"
  #     slack-message: "${{ github.event.inputs.network }} ${{ github.event.inputs.application }}* : *${{ needs.prepare.outputs.service }}* ${{ needs.prepare.outputs.version }}.${{ needs.prepare.outputs.tag_date }}.${{ needs.prepare.outputs.tag_git_hash }} is uploaded"
  #     channel: "orakl-notification"
  #   secrets:
  #     SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
  #   if: ${{ github.event.inputs.network == 'Baobab' && success() }}

  # image-update:
  #   name: Update image tag
  #   needs: [prepare, build]
  #   uses: ./.github/workflows/update.image-tag.yaml
  #   with:
  #     network: "baobab"
  #     project-name: ${{ github.event.inputs.application }}
  #     version: ${{ needs.prepare.outputs.version }}
  #     image-tag: ${{ needs.build.outputs.img_tag }}
  #     tag_date: ${{ needs.prepare.outputs.tag_date }}
  #     tag_git_hash: ${{ needs.prepare.outputs.tag_git_hash }}
  #   secrets:
  #     PAT: ${{ secrets.PAT }}
  #   if: ${{ github.event.inputs.network == 'Baobab' }}

  # post-slack-baobab-tag-update-success:
  #   name: Post slack message for tag update success
  #   needs: [prepare, build, image-update]
  #   uses: ./.github/workflows/post.slack.yaml
  #   with:
  #     status: "Success"
  #     slack-message: "${{ github.event.inputs.network }} *${{ github.event.inputs.application }}* : *${{ needs.prepare.outputs.service }}* new image tag ${{ needs.prepare.outputs.version }}.${{ needs.prepare.outputs.tag_date }}.${{ needs.prepare.outputs.tag_git_hash }} is updated"
  #     channel: "orakl-notification"
  #   secrets:
  #     SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
  #   if: ${{ github.event.inputs.network == 'Baobab' && success() }}

  # cypress-image-update:
  #   name: cypress image update
  #   uses: ./.github/workflows/update.image-tag.yaml
  #   with:
  #     network: "cypress"
  #     project-name: ${{ github.event.inputs.application }}
  #   secrets:
  #     PAT: ${{ secrets.PAT }}
  #   if: ${{ github.event.inputs.network == 'Cypress' }}

  # post-slack-cypress-tag-update-success:
  #   name: Post slack message for tag update success
  #   needs: [cypress-image-update]
  #   uses: ./.github/workflows/post.slack.yaml
  #   with:
  #     status: "Success"
  #     slack-message: "${{ github.event.inputs.network }} *${{ github.event.inputs.application }}* is updated"
  #     channel: "orakl-notification"
  #   secrets:
  #     SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
  #   if: ${{ github.event.inputs.network == 'Cypress' && success() }}
  # post-slack-tag-update-failure:
  #   name: Post to a slack message for tag update failure
  #   needs: [prepare, build, image-update]
  #   uses: ./.github/workflows/post.slack.yaml
  #   with:
  #     status: "Failed"
  #     slack-message: "${{ github.event.inputs.network }} *${{ github.event.inputs.application }}* git action failed"
  #     channel: "orakl-notification"
  #   secrets:
  #     SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
  #   if: ${{ github.event.inputs.network == 'Baobab' && failure() }}
  update-workflow-and-readme:
    name: Update Workflow and README
    # needs: [prepare, build, image-update]
    needs: [prepare]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
      pages: write
    outputs:
      pr_title: ${{ steps.pr_info.outputs.PR_TITLE }}
    steps:
      - uses: actions/checkout@master
        with:
          token: ${{ secrets.WORKFLOW_PAT }}
      - name: get latest merged pull request
        id: pr_info
        run: |
          pr=$(gh pr list --state merged --json title -L 1)
          PR_TITLE=$(echo $pr | jq -r '.[0].title')
          PR_TITLE=$(echo "${PR_TITLE}" | sed 's/\\/\\\\/g; s/"/\\"/g; s/`/\\`/g; s/\$/\\$/g')
          echo "PR_TITLE=${PR_TITLE}" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.WORKFLOW_PAT }}
      - name: Install yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
        # NEW_TAG=${{ github.event.inputs.application }}:${{ needs.build.outputs.img_tag }}
      - name: Update Workflow Dispatch Options
        run: |
          git stash
          git pull
          NEW_TAG=${{ github.event.inputs.application }}:vtestversion
          yq eval '.on.workflow_dispatch.inputs.image.options += ["'"${NEW_TAG}"'"]' -i .github/workflows/deployment.yaml
          git add .github/workflows/deployment.yaml
        env:
          GH_TOKEN: ${{ secrets.WORKFLOW_PAT }}
      - name: Update README with Latest PR Info
        run: |
          echo "- **${NEW_TAG}** <br> *\`PR\`*: ${{steps.pr_info.outputs.PR_TITLE}} <br><br> " >> README.md
          git add README.md
      - name: Commit & Push changes
        uses: actions-js/push@master
        with:
          github_token: ${{ secrets.WORKFLOW_PAT }}
          branch: ${{ github.ref }}
          repository: ${{ github.repository }}
  post-slack-pr-update:
    name: Post to a slack message for tag update failure
    # needs: [prepare, build, image-update, update-workflow-and-readme]
    needs: [prepare, update-workflow-and-readme]
    uses: ./.github/workflows/post.image.slack.yaml
    with:
      # slack-message: "${{ github.event.inputs.application }} *Tag Version:* ${{ needs.build.outputs.img_tag }} *PR:* ${{ needs.update-workflow-and-readme.outputs.pr_title}}"
      slack-message: "\\n \\n> *Service:* ${{ github.event.inputs.application }} \\n> *Version:* Test Image Version \\n> *PR:* ${{ needs.update-workflow-and-readme.outputs.pr_title}}"
      channel: "orakl-images"
    secrets:
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
    if: ${{ success() }}
