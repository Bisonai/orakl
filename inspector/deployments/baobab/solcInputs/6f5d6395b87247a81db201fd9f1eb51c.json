{
  "language": "Solidity",
  "sources": {
    "@bisonai/orakl-contracts/src/v0.1/interfaces/IAggregatorRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IAggregatorRouter {\n    function aggregatorProxies(string calldata feedName) external view returns (address);\n\n    function updateProxy(string calldata feedName, address proxyAddress) external;\n\n    function updateProxyBulk(\n        string[] calldata feedNames,\n        address[] calldata proxyAddresses\n    ) external;\n\n    function getRoundData(\n        string calldata feedName,\n        uint80 roundId\n    )\n        external\n        view\n        returns (\n            uint80 id,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData(\n        string calldata feedName\n    )\n        external\n        view\n        returns (\n            uint80 id,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function proposedGetRoundData(\n        string calldata feedName,\n        uint80 roundId\n    )\n        external\n        view\n        returns (\n            uint80 id,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function proposedLatestRoundData(\n        string calldata feedName\n    )\n        external\n        view\n        returns (\n            uint80 id,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function aggregator(string calldata feedName) external view returns (address);\n\n    function phaseId(string calldata feedName) external view returns (uint16);\n\n    function decimals(string calldata feedName) external view returns (uint8);\n\n    function typeAndVersion(string calldata feedName) external view returns (string memory);\n\n    function description(string calldata feedName) external view returns (string memory);\n\n    function proposedAggregator(string calldata feedName) external view returns (address);\n\n    function phaseAggregators(\n        string calldata feedName,\n        uint16 phaseId_\n    ) external view returns (address);\n}\n"
    },
    "@bisonai/orakl-contracts/src/v0.1/interfaces/ICoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface ICoordinatorBase {\n    // Fee configuration that separates fees based on the number of\n    // requests created per account. This applies only to [regular]\n    // account.\n    struct FeeConfig {\n        // Flat fee charged per fulfillment in millionths of KLAY\n        // So fee range is [0, 2^32/10^6].\n        uint32 fulfillmentFlatFeeKlayPPMTier1;\n        uint32 fulfillmentFlatFeeKlayPPMTier2;\n        uint32 fulfillmentFlatFeeKlayPPMTier3;\n        uint32 fulfillmentFlatFeeKlayPPMTier4;\n        uint32 fulfillmentFlatFeeKlayPPMTier5;\n        uint24 reqsForTier2;\n        uint24 reqsForTier3;\n        uint24 reqsForTier4;\n        uint24 reqsForTier5;\n    }\n\n    /**\n     * @notice Sets the configuration of the VRF coordinator\n     * @param maxGasLimit global max for request gas limit\n     * @param gasAfterPaymentCalculation gas used in doing accounting\n     * after completing the gas measurement\n     * @param feeConfig fee tier configuration\n     */\n    function setConfig(\n        uint32 maxGasLimit,\n        uint32 gasAfterPaymentCalculation,\n        FeeConfig memory feeConfig\n    ) external;\n\n    /**\n     * @notice Check to see if there exists a request commitment\n     * consumers for all consumers and keyhashes for a given acc.\n     * @param accId - ID of the account\n     * @return true if there exists at least one unfulfilled request\n     * for the account, false otherwise.\n     */\n    function pendingRequestExists(\n        address consumer,\n        uint64 accId,\n        uint64 nonce\n    ) external view returns (bool);\n\n    /**\n     * @notice Get request commitment.\n     * @param requestId id of request\n     * @return commmitment value that can be used to determine whether\n     * a request is fulfilled or not. If `requestId` is valid and\n     * commitment equals to bytes32(0), the request was fulfilled.\n     */\n    function getCommitment(uint256 requestId) external view returns (bytes32);\n\n    /**\n     * @notice Canceling oracle request\n     * @param requestId - ID of the Oracle Request\n     */\n    function cancelRequest(uint256 requestId) external;\n\n    /**\n     * @notice Access address for prepayment associated with\n     * @notice coordinator.\n     * @return prepayment address\n     */\n    function getPrepaymentAddress() external returns (address);\n\n    function estimateFee(\n        uint64 reqCount,\n        uint8 numSubmission,\n        uint32 callbackGasLimit\n    ) external returns (uint256);\n}\n"
    },
    "@bisonai/orakl-contracts/src/v0.1/interfaces/IRequestResponseCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./IRequestResponseCoordinatorBase.sol\";\nimport \"./ICoordinatorBase.sol\";\n\ninterface IRequestResponseCoordinator is IRequestResponseCoordinatorBase, ICoordinatorBase {}\n"
    },
    "@bisonai/orakl-contracts/src/v0.1/interfaces/IRequestResponseCoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"../libraries/Orakl.sol\";\n\ninterface IRequestResponseCoordinatorBase {\n    // RequestCommitment holds information sent from off-chain oracle\n    // describing details of request.\n    struct RequestCommitment {\n        uint64 blockNum;\n        uint64 accId;\n        uint8 numSubmission;\n        uint32 callbackGasLimit;\n        address sender;\n        bool isDirectPayment;\n        bytes32 jobId;\n    }\n\n    /**\n     * @notice Creates a request to RequestResponse oracle using a\n     * [regular] account.\n     * @dev Generates and stores a request ID, increments the local\n     * nonce, creates a request on the target oracle contract.\n     * @dev Emits Requested event.\n     * @param req The initialized Request\n     * @param callbackGasLimit - How much gas you'd like to receive in\n     * your fulfillRequest callback. Note that gasleft() inside\n     * fulfillRequest may be slightly less than this amount because of\n     * gas used calling the function (argument decoding etc.), so you\n     * may need to request slightly more than you expect to have\n     * inside fulfillRequest. The acceptable range is [0, maxGasLimit]\n     * @param accId - The ID of the account. Must be funded with the\n     * minimum account balance.\n     * @param numSubmission number of requested submission to compute\n     * the final aggregate value\n     @return requestId - A unique * identifier of the request. Can be\n     used to match a request to a * response in fulfillRequest.\n     */\n    function requestData(\n        Orakl.Request memory req,\n        uint32 callbackGasLimit,\n        uint64 accId,\n        uint8 numSubmission\n    ) external returns (uint256);\n\n    /**\n     * @notice Creates a request to RequestResponse oracle using a\n     * [temporary] account.\n     * @dev Generates and stores a request ID, increments the local\n     * nonce, creates a request on the target oracle contract.\n     * @dev Emits Requested event.\n     * @param req The initialized Request\n     * @param callbackGasLimit - How much gas you'd like to receive in\n     * your fulfillRequest callback. Note that gasleft() inside\n     * fulfillRequest may be slightly less than this amount because of\n     * gas used calling the function (argument decoding etc.), so you\n     * may need to request slightly more than you expect to have\n     * inside fulfillRequest. The acceptable range is [0, maxGasLimit]\n     * @param numSubmission number of requested submission to compute\n     * the final aggregate value\n     * @param refundRecipient recipient of an extra $KLAY amount that\n     * was sent together with service request\n     * @return requestId - A unique identifier of the request. Can be\n     * used to match a request to a response in fulfillRequest.\n     */\n    function requestData(\n        Orakl.Request memory req,\n        uint32 callbackGasLimit,\n        uint8 numSubmission,\n        address refundRecipient\n    ) external payable returns (uint256);\n\n    function fulfillDataRequestUint128(\n        uint256 requestId,\n        uint128 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestInt256(\n        uint256 requestId,\n        int256 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBool(\n        uint256 requestId,\n        bool response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestString(\n        uint256 requestId,\n        string memory response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBytes32(\n        uint256 requestId,\n        bytes32 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBytes(\n        uint256 requestId,\n        bytes memory response,\n        RequestCommitment memory rc\n    ) external;\n\n    /**\n     * @notice Different jobs specified by jobId have allowed\n     * different number of of requests for submissions that depends on\n     * total number of registered oracles.\n     */\n    function validateNumSubmission(bytes32 jobId, uint8 numSubmission) external;\n}\n"
    },
    "@bisonai/orakl-contracts/src/v0.1/interfaces/IVRFCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./IVRFCoordinatorBase.sol\";\nimport \"./ICoordinatorBase.sol\";\n\ninterface IVRFCoordinator is IVRFCoordinatorBase, ICoordinatorBase {}\n"
    },
    "@bisonai/orakl-contracts/src/v0.1/interfaces/IVRFCoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IVRFCoordinatorBase {\n    // RequestCommitment holds information sent from off-chain oracle\n    // describing details of request.\n    struct RequestCommitment {\n        uint256 blockNum;\n        uint64 accId;\n        uint32 callbackGasLimit;\n        uint32 numWords;\n        address sender;\n    }\n\n    /**\n     * @notice Get configuration relevant for making requests\n     * @return maxGasLimit global max for request gas limit\n     * @return sKeyHashes list of registered key hashes\n     */\n    function getRequestConfig() external view returns (uint32, bytes32[] memory);\n\n    /**\n     * @notice Request a set of random words using a [regular] account.\n     * @param keyHash - Corresponds to a particular oracle job which uses\n     * that key for generating the VRF proof. Different keyHash's have different gas price\n     * ceilings, so you can select a specific one to bound your maximum per request cost.\n     * @param accId - The ID of the account. Must be funded\n     * with the minimum account balance required for the selected keyHash.\n     * @param callbackGasLimit - How much gas you'd like to receive in your\n     * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n     * may be slightly less than this amount because of gas used calling the function\n     * (argument decoding etc.), so you may need to request slightly more than you expect\n     * to have inside fulfillRandomWords. The acceptable range is\n     * [0, maxGasLimit]\n     * @param numWords - The number of uint256 random values you'd like to receive\n     * in your fulfillRandomWords callback. Note these numbers are expanded in a\n     * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n     * @return requestId - A unique identifier of the request. Can be used to match\n     * a request to a response in fulfillRandomWords.\n     */\n    function requestRandomWords(\n        bytes32 keyHash,\n        uint64 accId,\n        uint32 callbackGasLimit,\n        uint32 numWords\n    ) external returns (uint256 requestId);\n\n    /**\n     * @notice Request a set of random words using a [temporary] account.\n     * @param keyHash - Corresponds to a particular oracle job which uses\n     * that key for generating the VRF proof. Different keyHash's have different gas price\n     * ceilings, so you can select a specific one to bound your maximum per request cost.\n     * @param callbackGasLimit - How much gas you'd like to receive in your\n     * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n     * may be slightly less than this amount because of gas used calling the function\n     * (argument decoding etc.), so you may need to request slightly more than you expect\n     * to have inside fulfillRandomWords. The acceptable range is\n     * [0, maxGasLimit]\n     * @param numWords - The number of uint256 random values you'd like to receive\n     * in your fulfillRandomWords callback. Note these numbers are expanded in a\n     * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n     * @param refundRecipient recipient of an extra $KLAY amount that\n     * was sent together with service request\n     * @return requestId - A unique identifier of the request. Can be used to match\n     * a request to a response in fulfillRandomWords.\n     */\n    function requestRandomWords(\n        bytes32 keyHash,\n        uint32 callbackGasLimit,\n        uint32 numWords,\n        address refundRecipient\n    ) external payable returns (uint256 requestId);\n}\n"
    },
    "@bisonai/orakl-contracts/src/v0.1/libraries/Buffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint256 capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Initializes a new buffer from an existing bytes object.\n     *      Changes to the buffer may mutate the original value.\n     * @param b The bytes object to initialize the buffer with.\n     * @return A new buffer.\n     */\n    function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint256 capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n     * @dev Sets buffer length to 0.\n     * @param buf The buffer to truncate.\n     * @return The original buffer, for chaining..\n     */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(\n        buffer memory buf,\n        uint256 off,\n        bytes memory data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint256 dest;\n        uint256 src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint256 mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function append(\n        buffer memory buf,\n        bytes memory data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, len);\n    }\n\n    /**\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    /**\n     * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write the byte at.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function writeUint8(\n        buffer memory buf,\n        uint256 off,\n        uint8 data\n    ) internal pure returns (buffer memory) {\n        if (off >= buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if eq(off, buflen) {\n                mstore(bufptr, add(buflen, 1))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n        return writeUint8(buf, buf.buf.length, data);\n    }\n\n    /**\n     * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @param len The number of bytes to write (left-aligned).\n     * @return The original buffer, for chaining.\n     */\n    function write(\n        buffer memory buf,\n        uint256 off,\n        bytes32 data,\n        uint256 len\n    ) private pure returns (buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        unchecked {\n            uint256 mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + off + len\n                let dest := add(add(bufptr, off), len)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(add(off, len), mload(bufptr)) {\n                    mstore(bufptr, add(off, len))\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function writeBytes20(\n        buffer memory buf,\n        uint256 off,\n        bytes20 data\n    ) internal pure returns (buffer memory) {\n        return write(buf, off, bytes32(data), 20);\n    }\n\n    /**\n     * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chhaining.\n     */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, bytes32(data), 20);\n    }\n\n    /**\n     * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, 32);\n    }\n\n    /**\n     * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer, for chaining.\n     */\n    function writeInt(\n        buffer memory buf,\n        uint256 off,\n        uint256 data,\n        uint256 len\n    ) private pure returns (buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint256 mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + off + sizeof(buffer length) + len\n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function appendInt(\n        buffer memory buf,\n        uint256 data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        return writeInt(buf, buf.buf.length, data, len);\n    }\n}\n"
    },
    "@bisonai/orakl-contracts/src/v0.1/libraries/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vendor/CBORChainlink.sol\n\nimport {Buffer} from \"./Buffer.sol\";\n\n// Encoding library for Binary Object Representation\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    // DECLARE TYPES FOR EASIER REFERENCE OF VARIABLE TYPE\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    function encodeFixedNumeric(Buffer.buffer memory buf, uint8 major, uint64 value) private pure {\n        if (value <= 23) {\n            buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.appendUint8(uint8((major << 5) | 24));\n            buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.appendUint8(uint8((major << 5) | 25));\n            buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.appendUint8(uint8((major << 5) | 26));\n            buf.appendInt(value, 4);\n        } else {\n            buf.appendUint8(uint8((major << 5) | 27));\n            buf.appendInt(value, 8);\n        }\n    }\n\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n        buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n        if (value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, value);\n        } else {\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        }\n    }\n\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n        if (value < -0x10000000000000000) {\n            encodeSignedBigNum(buf, value);\n        } else if (value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, uint(value));\n        } else if (value >= 0) {\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n        } else {\n            encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n        }\n    }\n\n    function encodeBytes(Buffer.buffer memory buf, bytes memory value) internal pure {\n        encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.append(value);\n    }\n\n    function encodeBigNum(Buffer.buffer memory buf, uint value) internal pure {\n        buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        encodeBytes(buf, abi.encode(value));\n    }\n\n    function encodeSignedBigNum(Buffer.buffer memory buf, int input) internal pure {\n        buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n        encodeBytes(buf, abi.encode(uint256(-1 - input)));\n    }\n\n    function encodeString(Buffer.buffer memory buf, string memory value) internal pure {\n        encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.append(bytes(value));\n    }\n\n    function startArray(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n    }\n\n    function startMap(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n    }\n\n    function endSequence(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n    }\n}\n"
    },
    "@bisonai/orakl-contracts/src/v0.1/libraries/Orakl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Chainlink.sol\n\nimport {Buffer} from \"./Buffer.sol\";\nimport {CBOR} from \"./CBOR.sol\";\n\nlibrary Orakl {\n    uint256 internal constant defaultBufferSize = 256;\n\n    using CBOR for Buffer.buffer;\n\n    // structure for storing requests done off-chain\n    struct Request {\n        bytes32 id;\n        address callbackAddr;\n        bytes4 callbackFunc;\n        uint256 nonce;\n        Buffer.buffer buf;\n    }\n\n    /**\n     * @notice Initializes a request\n     * @dev Sets ID, callback address, and callback function\n     * @param self The uninitialized request\n     * @param jobId The Job Specification ID\n     * @param callbackAddr The callback address\n     * @param callbackFunc The callback function signature\n     * @return The initialized request\n     */\n    function initialize(\n        Request memory self,\n        bytes32 jobId,\n        address callbackAddr,\n        bytes4 callbackFunc\n    ) internal pure returns (Orakl.Request memory) {\n        Buffer.init(self.buf, defaultBufferSize);\n        self.id = jobId;\n        self.callbackAddr = callbackAddr;\n        self.callbackFunc = callbackFunc;\n        return self;\n    }\n\n    /**\n     * @notice sets the data for buffer\n     * @param _request the initialized request\n     * @param _data the CBOR data\n     */\n    function setBuffer(Request memory _request, bytes memory _data) internal pure {\n        Buffer.init(_request.buf, _data.length);\n        Buffer.append(_request.buf, _data);\n    }\n\n    /**\n     * @notice Adds a string value to the request in a key - value pair format\n     * @param self - the initalized request\n     * @param key - the name of the key\n     * @param value - the string value to add\n     */\n    function add(Request memory self, string memory key, string memory value) internal pure {\n        self.buf.encodeString(key);\n        self.buf.encodeString(value);\n    }\n\n    /**\n     * @notice Adds a byte value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the bytes value to add\n     */\n    function addBytes(\n        Request memory _request,\n        string memory _key,\n        bytes memory _value\n    ) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeBytes(_value);\n    }\n\n    /**\n     * @notice Adds a Int256 value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the int256 value to add\n     */\n    function addInt(Request memory _request, string memory _key, int256 _value) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeInt(_value);\n    }\n\n    /**\n     * @notice Adds a UInt256 value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the uint256 value to add\n     */\n    function addUInt(Request memory _request, string memory _key, uint256 _value) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeUInt(_value);\n    }\n\n    /**\n     * @notice Adds an array of string value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _values - the array of string value to add\n     */\n    function addStringArray(\n        Request memory _request,\n        string memory _key,\n        string[] memory _values\n    ) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.startArray();\n        for (uint256 i; i < _values.length; i++) {\n            _request.buf.encodeString(_values[i]);\n        }\n        _request.buf.endSequence();\n    }\n}\n"
    },
    "contracts/InspectorConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {InspectorConsumerBase} from \"./InspectorConsumerBase.sol\";\nimport {IAggregatorRouter} from \"@bisonai/orakl-contracts/src/v0.1/interfaces/IAggregatorRouter.sol\";\nimport {Orakl} from \"@bisonai/orakl-contracts/src/v0.1/libraries/Orakl.sol\";\nimport {IVRFCoordinator} from \"@bisonai/orakl-contracts/src/v0.1/interfaces/IVRFCoordinator.sol\";\n\ncontract InspectorConsumer is InspectorConsumerBase{\n    using Orakl for Orakl.Request;\n\n    uint256 public sRandomWord;\n    uint128 public sResponse;\n    address private sOwner;\n\n    IVRFCoordinator vrfCoordinator;\n    IAggregatorRouter internal router;\n\n    error OnlyOwner(address notOwner);\n\n    modifier onlyOwner() {\n        if (msg.sender != sOwner) {\n            revert OnlyOwner(msg.sender);\n        }\n        _;\n    }\n\n    constructor(address aggregatorRouter, address _rrCoordinator, address _vrfCoordinator)InspectorConsumerBase(_vrfCoordinator, _rrCoordinator){\n        sOwner = msg.sender;\n        router = IAggregatorRouter(aggregatorRouter);\n        vrfCoordinator = IVRFCoordinator(_vrfCoordinator);\n    }\n\n    // Receive remaining payment from requestDataPayment\n    receive() external payable {}\n\n    function requestDataFeed(string calldata pair) public view returns (uint80 roundId, int256 answer){\n        (\n            uint80 roundId_,\n            int256 answer_\n            , /* uint startedAt */\n            , /* uint updatedAt */\n            , /* uint80 answeredInRound */\n        ) = router.latestRoundData(pair);\n        return (roundId_, answer_);\n    }\n\n    function decimals(string calldata pair) public view returns (uint8) {\n        return router.decimals(pair);\n    }\n\n    function requestRR(\n        uint64 accId,\n        uint32 callbackGasLimit\n    ) public onlyOwner returns (uint256 requestId) {\n        bytes32 jobId = keccak256(abi.encodePacked(\"uint128\"));\n        uint8 numSubmission = 1;\n\n        Orakl.Request memory req = buildRequest(jobId);\n        req.add(\"get\", \"https://api.coinbase.com/v2/exchange-rates?currency=BTC\");\n        req.add(\"path\", \"data,rates,USDT\");\n        req.add(\"pow10\", \"8\");\n\n        requestId = rrCoordinator.requestData(req, callbackGasLimit, accId, numSubmission);\n    }\n\n    function requestRRDirect(\n        uint32 callbackGasLimit\n    ) public payable returns (uint256 requestId) {\n        bytes32 jobId = keccak256(abi.encodePacked(\"uint128\"));\n        uint8 numSubmission = 1;\n\n        Orakl.Request memory req = buildRequest(jobId);\n        req.add(\"get\", \"https://api.coinbase.com/v2/exchange-rates?currency=BTC\");\n        req.add(\"path\", \"data,rates,USDT\");\n        req.add(\"pow10\", \"8\");\n\n        requestId = rrCoordinator.requestData{value: msg.value}(\n            req,\n            callbackGasLimit,\n            numSubmission,\n            address(this)\n        );\n    }\n\n    function requestVRF(\n        bytes32 keyHash,\n        uint64 accId,\n        uint32 callbackGasLimit,\n        uint32 numWords\n    ) public onlyOwner returns (uint256 requestId) {\n        requestId = vrfCoordinator.requestRandomWords(keyHash, accId, callbackGasLimit, numWords);\n    }\n\n    function requestVRFDirect(\n        bytes32 keyHash,\n        uint32 callbackGasLimit,\n        uint32 numWords,\n        address refundRecipient\n    ) public payable returns (uint256 requestId) {\n        requestId = vrfCoordinator.requestRandomWords{value: msg.value}(\n            keyHash,\n            callbackGasLimit,\n            numWords,\n            refundRecipient\n        );\n    }\n\n    function fulfillRandomWords(\n        uint256 /* requestId */,\n        uint256[] memory randomWords\n    ) internal override {\n        // requestId should be checked if it matches the expected request\n        // Generate random value between 1 and 50.\n        sRandomWord = (randomWords[0] % 50) + 1;\n    }\n\n    function fulfillDataRequest(uint256 /*requestId*/, uint128 response) internal override {\n        sResponse = response;\n    }\n\n    function cancelRequest(uint256 requestId) external onlyOwner {\n        rrCoordinator.cancelRequest(requestId);\n    }\n\n\n}"
    },
    "contracts/InspectorConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {Orakl} from \"@bisonai/orakl-contracts/src/v0.1/libraries/Orakl.sol\";\nimport {IRequestResponseCoordinator} from \"@bisonai/orakl-contracts/src/v0.1/interfaces/IRequestResponseCoordinator.sol\";\n\n\nabstract contract InspectorConsumerBase {\n    using Orakl for Orakl.Request;\n\n    error OnlyCoordinatorCanFulfill(address have, address want);\n\n    address private immutable vrfCoordinator;\n    IRequestResponseCoordinator public immutable rrCoordinator;\n    mapping(bytes32 => bytes4) private sJobIdToFunctionSelector;\n\n    constructor(address _vrfCoordinator, address _rrCoordinator) {\n        vrfCoordinator = _vrfCoordinator;\n        rrCoordinator = IRequestResponseCoordinator(_rrCoordinator);\n        sJobIdToFunctionSelector[keccak256(abi.encodePacked(\"uint128\"))] = rrCoordinator\n            .fulfillDataRequestUint128\n            .selector;\n        sJobIdToFunctionSelector[keccak256(abi.encodePacked(\"int256\"))] = rrCoordinator\n            .fulfillDataRequestInt256\n            .selector;\n        sJobIdToFunctionSelector[keccak256(abi.encodePacked(\"bool\"))] = rrCoordinator\n            .fulfillDataRequestBool\n            .selector;\n        sJobIdToFunctionSelector[keccak256(abi.encodePacked(\"string\"))] = rrCoordinator\n            .fulfillDataRequestString\n            .selector;\n        sJobIdToFunctionSelector[keccak256(abi.encodePacked(\"bytes32\"))] = rrCoordinator\n            .fulfillDataRequestBytes32\n            .selector;\n        sJobIdToFunctionSelector[keccak256(abi.encodePacked(\"bytes\"))] = rrCoordinator\n            .fulfillDataRequestBytes\n            .selector;\n    }\n\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n    function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n        if (msg.sender != vrfCoordinator) {\n            revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n        }\n        fulfillRandomWords(requestId, randomWords);\n    }\n\n    function buildRequest(bytes32 jobId) internal view returns (Orakl.Request memory req) {\n        return req.initialize(jobId, address(rrCoordinator), sJobIdToFunctionSelector[jobId]);\n    }\n\n    function fulfillDataRequest(uint256 requestId, uint128 response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        uint128 response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n\n    modifier verifyRawFulfillment() {\n        address coordinatorAddress = address(rrCoordinator);\n        if (msg.sender != coordinatorAddress) {\n            revert OnlyCoordinatorCanFulfill(msg.sender, coordinatorAddress);\n        }\n        _;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}